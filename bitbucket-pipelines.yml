image: node:20

pipelines:
  default:
    - step:
        name: Build & Deploy to Production
        caches:
          - node
        script:
          # 0) Clean NPM cache
          - npm cache clean --force
          # 1) Install dependencies
          - npm ci
          # 2) Build the app
          - npm run build
          # 3) Verify build output
          - ls -la .next
          # 4) Install zip
          - apt-get update && apt-get install -y zip
          # 5) Create startup script for Azure
          - |
            cat > server.js << 'EOF'
            const { createServer } = require('http')
            const { parse } = require('url')
            const next = require('next')
            
            const dev = process.env.NODE_ENV !== 'production'
            const hostname = '0.0.0.0'
            const port = process.env.PORT || 3000
            
            const app = next({ dev, hostname, port })
            const handle = app.getRequestHandler()
            
            app.prepare().then(() => {
              createServer(async (req, res) => {
                try {
                  const parsedUrl = parse(req.url, true)
                  await handle(req, res, parsedUrl)
                } catch (err) {
                  console.error('Error occurred handling', req.url, err)
                  res.statusCode = 500
                  res.end('internal server error')
                }
              })
                .once('error', (err) => {
                  console.error(err)
                  process.exit(1)
                })
                .listen(port, () => {
                  console.log(`> Ready on http://${hostname}:${port}`)
                })
            })
            EOF
          # 6) Create web.config for Azure
          - |
            cat > web.config << 'EOF'
            <?xml version="1.0" encoding="utf-8"?>
            <configuration>
              <system.webServer>
                <handlers>
                  <add name="iisnode" path="server.js" verb="*" modules="iisnode"/>
                </handlers>
                <rewrite>
                  <rules>
                    <rule name="NodeInspector" patternSyntax="ECMAScript" stopProcessing="true">
                      <match url="^server.js\/debug[\/]?" />
                    </rule>
                    <rule name="StaticContent">
                      <action type="Rewrite" url="public{REQUEST_URI}"/>
                    </rule>
                    <rule name="DynamicContent">
                      <conditions>
                        <add input="{REQUEST_FILENAME}" matchType="IsFile" negate="True"/>
                      </conditions>
                      <action type="Rewrite" url="server.js"/>
                    </rule>
                  </rules>
                </rewrite>
                <security>
                  <requestFiltering>
                    <hiddenSegments>
                      <remove segment="bin"/>
                    </hiddenSegments>
                  </requestFiltering>
                </security>
                <httpErrors existingResponse="PassThrough" />
                <iisnode watchedFiles="web.config;*.js"/>
              </system.webServer>
            </configuration>
            EOF
          # 7) Install production dependencies in a clean directory
          - npm ci --omit=dev --production
          # 8) Package all necessary files for Azure deployment
          - zip -r release.zip .next public package.json package-lock.json next.config.* server.js web.config node_modules -x "node_modules/.cache/*" "*.git*" ".env*"
          # 9) Debug: ensure variables exist
          - echo "Deploying ${BITBUCKET_BRANCH} branch to Production Web App"
          - echo "AZURE_SCM_URL=$AZURE_SCM_URL"
          - echo "DEPLOY_USER=$DEPLOY_USER"
          - echo "DEPLOY_PWD length=${#DEPLOY_PWD}"
          - |
            if [ -z "$AZURE_SCM_URL" ] || [ -z "$DEPLOY_USER" ] || [ -z "$DEPLOY_PWD" ]; then
              echo "‚ùå Missing one or more deployment variables"
              exit 1
            fi
          # 10) Confirm release.zip exists and show size
          - ls -lh release.zip || { echo "‚ùå release.zip not found"; exit 1; }
          # 11) Deploy via Kudu Zip Deploy with better error handling
          - |
            echo "üöÄ Starting deployment to Azure..."
            DEPLOY_RESPONSE=$(curl -X POST -u "$DEPLOY_USER:$DEPLOY_PWD" \
              "https://$AZURE_SCM_URL/api/zipdeploy" \
              --data-binary "@release.zip" \
              --write-out "HTTPSTATUS:%{http_code}" \
              --silent \
              --output /tmp/deploy_response.txt)
            
            HTTP_STATUS=$(echo $DEPLOY_RESPONSE | tr -d '\n' | sed -E 's/.*HTTPSTATUS:([0-9]{3})$/\1/')
            
            if [ "$HTTP_STATUS" -eq 200 ] || [ "$HTTP_STATUS" -eq 202 ]; then
              echo "‚úÖ Deployment initiated successfully (HTTP $HTTP_STATUS)"
              echo "üìù Response:"
              cat /tmp/deploy_response.txt
            else
              echo "‚ùå Deployment failed (HTTP $HTTP_STATUS)"
              echo "üìù Error response:"
              cat /tmp/deploy_response.txt
              exit 1
            fi
          # 12) Wait and verify deployment
          - |
            echo "‚è≥ Waiting 60 seconds for deployment to complete..."
            sleep 60
            
            if [ -n "$AZURE_APP_URL" ]; then
              echo "üîç Verifying deployment at $AZURE_APP_URL"
              if curl -f -s "$AZURE_APP_URL" > /dev/null; then
                echo "‚úÖ App is responding successfully!"
              else
                echo "‚ö†Ô∏è  App might still be starting up. Check Azure portal for status."
              fi
            else
              echo "‚ÑπÔ∏è  Set AZURE_APP_URL variable to verify deployment automatically"
            fi
            
            echo "üéâ Deployment process completed!"